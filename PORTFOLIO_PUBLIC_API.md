# 공공 API와 로컬 캐싱을 결합한 하이브리드 약물 정보 시스템

## 구현 배경

피임약 복용 관리 앱에서 사용자에게 정확한 약물 정보를 제공하기 위해 식품의약품안전처의 의약품 제품 허가정보 API를 연동하였습니다. 기존에는 사용자가 약 이름과 복용일, 휴약일을 수동으로 입력해야 했으나, 이는 다음과 같은 문제점이 있었습니다.

첫째, 사용자가 복용 주기를 잘못 입력할 수 있습니다. 피임약마다 21일 복용 7일 휴약, 24일 복용 4일 휴약 등 다양한 복용법이 존재하는데, 이를 정확히 알지 못하면 잘못된 일정 관리로 이어집니다.

둘째, 약물의 상세 정보를 제공할 수 없습니다. 성분, 제조사, 복용 주의사항 등의 정보가 없으면 AI 어드바이저가 맞춤형 조언을 제공하기 어렵습니다.

셋째, 타이핑 오류로 인한 약물명 불일치가 발생합니다. 사용자가 직접 입력한 약 이름이 표준 명칭과 다를 경우, 약물 정보를 매칭하기 어렵습니다.

이러한 문제를 해결하기 위해 공공 API를 활용한 실시간 약물 검색 및 자동완성 기능을 구현하였으며, 네트워크 효율성과 오프라인 대응을 위해 로컬 캐싱을 결합한 하이브리드 아키텍처를 설계하였습니다.

## 사용자 경험 플로우

약 설정 화면에서 사용자가 약 이름을 입력하기 시작하면, 입력된 텍스트를 기반으로 실시간 검색이 수행됩니다. 검색 결과는 텍스트 필드 하단에 자동완성 리스트로 표시되며, 사용자가 원하는 약물을 탭하면 해당 약물의 복용일과 휴약일이 자동으로 입력됩니다. 또한 약물의 성분, 제조사, 복용법 등의 상세 정보가 함께 저장되어, 이후 사이클 데이터 조회 시 약물 정보를 함께 제공할 수 있습니다.

예를 들어, 사용자가 "야즈"를 검색하면 "야즈정"이 자동완성 리스트에 표시되고, 이를 선택하면 24일 복용 4일 휴약이 자동으로 설정됩니다. 이는 사용자의 입력 부담을 줄이고 정확한 복용 주기를 보장합니다.

## 아키텍처 설계

### 계층 분리 구조

데이터 흐름을 명확히 분리하기 위해 DTO, Domain Model, Repository 계층을 구축하였습니다.

#### DTO 계층

API 응답 형식인 JSON 구조를 그대로 매핑하는 MedicationDTO를 정의하였습니다. Swift의 Codable 프로토콜을 활용하여 API 필드명인 ITEM_NAME, ENTP_NAME, MAIN_ITEM_INGR, UD_DOC_DATA 등을 CodingKeys로 매핑하였으며, 외부 API 스키마 변경이 내부 도메인 로직에 영향을 주지 않도록 격리하였습니다.

API 응답 구조는 header와 body로 구성되며, header에는 resultCode와 resultMsg가 포함되어 API 호출 성공 여부를 판별할 수 있습니다. body에는 items 배열과 함께 총 개수, 페이지 정보가 포함됩니다. 각 MedicationItem에는 품목기준코드, 품목명, 업체명, 주성분, 용법용량, 포장단위, 저장방법, 허가일자 등이 포함됩니다.

#### Domain Model

비즈니스 로직에서 사용하는 MedicationInfo 모델을 별도로 정의하였습니다. DTO에서 Domain Model로 변환하는 toDomainModel 메서드를 구현하여, API 응답의 옵셔널 값을 안전하게 처리하고 기본값을 제공합니다.

약물명 정규화 검색 로직을 Domain Model의 확장으로 캡슐화하였습니다. 띄어쓰기와 "정" 접미사를 제거한 후 대소문자를 무시하여 비교함으로써, 사용자 입력 오차를 허용하는 유연한 검색이 가능합니다. 또한 품목명에 "경구피임", "피임약", "피임제" 키워드가 포함되어 있는지 확인하는 메서드를 제공하여, 피임약만 필터링할 수 있도록 하였습니다.

#### Repository 패턴

데이터 소스를 추상화하는 MedicationRepositoryProtocol을 정의하고, 구체적인 구현체인 MedicationRepositoryImpl에서 3단계 데이터 제공 로직을 구현하였습니다. 이를 통해 ViewModel은 데이터의 출처를 알 필요 없이 Repository 인터페이스만 의존하도록 하여 테스트 가능성을 높였습니다.

Repository는 피임약 검색, 키워드 검색, 캐시 수동 갱신 메서드를 제공하며, 모든 메서드는 RxSwift의 Observable을 반환하여 비동기 처리를 일관성 있게 관리합니다.

### 3단계 데이터 제공 전략

#### 1단계: 로컬 캐시 우선 조회

앱 실행 시 UserDefaults에 저장된 캐시 데이터를 먼저 확인합니다. 캐시 데이터와 함께 저장된 타임스탬프를 현재 시각과 비교하여 7일 이내의 데이터라면 즉시 반환합니다. 이를 통해 네트워크 호출 없이 밀리초 단위의 빠른 응답 속도를 제공합니다.

캐시 키는 검색 키워드별로 분리하여 관리합니다. 예를 들어, "피임약" 검색 결과와 "야즈" 검색 결과를 각각 캐싱함으로써, 동일한 검색어에 대해 반복적으로 API를 호출하지 않도록 최적화하였습니다. 캐시 용량 제한을 고려하여 최근 10개 검색 결과만 유지하고, LRU 방식으로 오래된 캐시를 삭제합니다.

#### 2단계: API 호출 및 캐시 갱신

캐시가 존재하지 않거나 만료되었을 경우, 식약처 API를 호출합니다. URLSession을 활용하여 비동기 네트워크 요청을 수행하며, URLComponents를 통해 쿼리 파라미터를 안전하게 인코딩합니다. API 호출 시 서비스 키, 품목명, 응답 형식, 페이지 번호, 결과 개수를 파라미터로 전달합니다.

응답 성공 시 HTTP 상태 코드가 200번대인지 확인하고, JSON 데이터를 DTO로 파싱합니다. 파싱된 DTO는 header의 resultCode가 "00"인지 검증하여 API 레벨 에러를 체크합니다. 검증을 통과한 데이터는 Domain Model로 변환되며, JSONEncoder를 통해 직렬화하여 UserDefaults에 저장합니다. 현재 타임스탬프를 함께 기록하여 캐시 만료 여부를 판단할 수 있도록 합니다.

RxSwift의 Observable.create를 활용하여 비동기 URLSession 작업을 Observable로 래핑하였으며, Disposables.create에서 URLSessionTask를 cancel하도록 하여 Observable이 dispose될 때 네트워크 요청도 취소되도록 구현하였습니다.

#### 3단계: 폴백 데이터 제공

API 호출이 실패하거나 네트워크가 불안정한 경우, 앱에 하드코딩된 기본 약물 정보를 반환합니다. 기본 데이터는 식약처 첨부문서를 기반으로 작성된 18종의 피임약 정보를 포함하며, 오프라인 환경에서도 최소한의 기능을 보장합니다.

폴백 데이터는 기존에 구현되어 있던 PillDatabase를 활용합니다. PillDatabase는 각 약물의 이름, 성분, 복용 주기, 적응증, 혈전 위험도 등을 타입 세이프하게 관리하며, 검색 메서드를 제공합니다. API 에러 발생 시 PillDatabase에서 동일한 키워드로 검색하여 결과를 반환함으로써, 사용자 경험이 중단되지 않도록 하였습니다.

에러 핸들링 단계에서 catchError 연산자를 활용하여, 네트워크 에러나 파싱 에러가 발생하면 자동으로 폴백 데이터를 반환하는 Observable로 전환됩니다. 사용자에게는 "네트워크 연결이 불안정하여 기본 정보를 제공합니다"와 같은 안내 메시지를 표시합니다.

## 기술 구현 세부사항

### 에러 핸들링 계층

MedicationAPIError 열거형을 정의하여 다양한 실패 시나리오를 타입 세이프하게 관리하였습니다. 네트워크 연결 실패는 networkError로, HTTP 상태 코드 에러는 httpError로, JSON 파싱 실패는 decodingError로, API 응답 코드 에러는 apiError로 구분합니다. 각 에러 케이스는 연관값을 통해 구체적인 정보를 저장하며, LocalizedError 프로토콜을 준수하여 사용자 친화적인 에러 메시지를 제공합니다.

에러 발생 시 로그를 기록하고, 자동으로 폴백 데이터로 전환됩니다. 에러 로그에는 에러 타입, 발생 시각, 요청 파라미터가 포함되어 디버깅을 용이하게 합니다. 프로덕션 환경에서는 Firebase Crashlytics와 같은 모니터링 도구로 에러를 수집하여 API 호출 실패율을 추적할 수 있습니다.

### 지역 감지 로직

Locale.current.region?.identifier를 활용하여 사용자의 국가 코드를 확인합니다. 국가 코드가 "KR"이 아닌 경우 API 호출을 생략하고 캐시 또는 폴백 데이터만 사용합니다. 이는 한국 외 지역에서 불필요한 API 트래픽을 방지하고, 해외 사용자에게는 기본 정보만 제공하는 정책을 구현한 것입니다.

지역 감지는 Repository 초기화 시점에 수행되며, 결과를 변수에 캐싱하여 매 요청마다 체크하지 않도록 최적화하였습니다. 또한 설정 화면에서 사용자가 수동으로 지역을 변경할 수 있도록 옵션을 제공하여, VPN 사용 등으로 인한 오탐지를 대응할 수 있습니다.

### API 키 보안 관리

민감한 API 키를 코드에 직접 포함하지 않기 위해 xcconfig 파일을 생성하여 환경 변수로 관리합니다. Config.xcconfig 파일에 MFDS_API_KEY 변수를 정의하고, Info.plist에서 이 값을 참조하도록 설정합니다. Bundle.main.object(forInfoDictionaryKey:) 메서드를 통해 런타임에 키를 읽어옵니다.

xcconfig 파일은 .gitignore에 추가하여 버전 관리 시스템에 업로드되지 않도록 하였으며, 팀원에게는 Config.xcconfig.template 파일과 함께 별도 문서로 공유합니다. CI/CD 파이프라인에서는 환경 변수로 API 키를 주입받아 빌드 시점에 xcconfig 파일을 생성하도록 설정합니다.

향후에는 백엔드 프록시 서버를 구축하여 클라이언트가 자체 서버를 통해 간접적으로 API를 호출하도록 개선할 계획입니다. 이를 통해 클라이언트 바이너리에서 API 키가 완전히 제거되며, 서버 측에서 요청 횟수 제한과 로깅을 중앙 관리할 수 있습니다.

### 캐시 무효화 정책

약물 허가 정보는 빈번하게 변경되지 않지만, 신약 출시나 허가 취소가 발생할 수 있습니다. 이를 고려하여 7일 단위의 Time-to-Live 정책을 적용하였습니다. UserDefaults에 캐시 데이터와 함께 저장된 타임스탬프를 현재 시각과 비교하여, 7일이 경과했을 경우 캐시를 무효화하고 API를 재호출합니다.

사용자가 앱을 실행할 때마다 백그라운드에서 자동으로 캐시 유효성을 검증하며, 만료된 캐시는 비동기적으로 갱신됩니다. 갱신 중에도 만료된 캐시를 임시로 반환하여 사용자 경험이 중단되지 않도록 하였으며, 갱신 완료 후 UI를 업데이트합니다.

또한 설정 화면에 수동 새로고침 버튼을 제공하여 사용자가 즉시 최신 정보를 받을 수 있도록 하였습니다. 수동 새로고침 시에는 캐시를 강제로 삭제하고 API를 호출하며, 로딩 인디케이터를 표시하여 진행 상황을 시각적으로 전달합니다.

### 실시간 검색 UI 구현

약 설정 화면의 TextField에 텍스트 입력 이벤트를 바인딩하여 실시간 검색을 구현하였습니다. RxSwift의 debounce 연산자를 활용하여 사용자가 타이핑을 멈춘 후 0.3초 뒤에 검색을 수행함으로써, 과도한 API 호출을 방지하였습니다.

검색 결과는 TextField 하단에 동적으로 나타나는 TableView로 표시됩니다. TableView의 높이는 검색 결과 개수에 따라 자동으로 조정되며, 최대 5개 항목까지 표시하고 그 이상은 스크롤로 처리합니다. 검색 결과가 없을 경우 "검색 결과가 없습니다" 메시지를 표시합니다.

각 TableViewCell에는 약물명, 제조사, 주성분을 표시하며, 사용자가 셀을 탭하면 해당 약물 정보가 선택됩니다. 선택된 약물의 복용일과 휴약일은 UD_DOC_DATA 필드를 파싱하여 추출합니다. 예를 들어, "1일 1정, 21일 복용 후 7일 휴약"과 같은 텍스트에서 정규표현식을 사용하여 숫자를 추출합니다.

### 약물 정보 자동 입력 로직

사용자가 자동완성 리스트에서 약물을 선택하면, 해당 약물의 상세 정보를 파싱하여 복용일과 휴약일을 자동으로 입력합니다. API 응답의 UD_DOC_DATA 필드에는 용법용량 정보가 텍스트 형식으로 포함되어 있으며, 이를 파싱하는 전용 파서를 구현하였습니다.

파서는 정규표현식을 활용하여 "21일 복용", "7일 휴약" 등의 패턴을 인식합니다. 다양한 표현 방식을 처리하기 위해 "복용", "투여", "투약" 등의 동의어와 "휴약", "쉬기", "중단" 등의 동의어를 모두 인식하도록 하였습니다. 파싱에 실패할 경우 기본값으로 21일 복용 7일 휴약을 설정합니다.

파싱된 복용일과 휴약일은 ViewModel의 Relay에 전달되어 UI에 반영되며, 사용자는 자동 입력된 값을 확인하고 필요시 수정할 수 있습니다. 수정된 값은 PillInfo 객체에 저장되어 이후 사이클 생성 시 사용됩니다.

### 약물 정보 데이터 저장 확장

기존 PillInfo 모델은 약 이름, 복용일, 휴약일만 저장하였으나, API 연동 후에는 제조사, 주성분, 복용법, 허가일자 등의 추가 정보를 저장할 필요가 있습니다. 이를 위해 PillInfo 모델을 확장하였으며, Codable 프로토콜을 유지하여 기존 저장 로직과의 호환성을 보장합니다.

확장된 필드들은 옵셔널로 정의하여 기존 데이터와의 호환성을 유지합니다. 기존에 저장된 PillInfo는 추가 필드가 nil이며, API를 통해 저장된 PillInfo는 상세 정보가 포함됩니다. 이를 통해 점진적인 마이그레이션이 가능하며, 기존 사용자의 데이터가 손실되지 않습니다.

저장된 약물 정보는 사이클 조회 시 함께 반환되어, 통계 화면이나 히스토리 화면에서 약물명과 제조사를 표시할 수 있습니다. 또한 AI 어드바이저가 약물의 성분 정보를 활용하여 맞춤형 조언을 제공할 수 있도록 합니다.

### 비동기 처리 및 UI 바인딩

RxSwift를 활용하여 비동기 API 호출 결과를 ViewModel과 바인딩하였습니다. Repository의 메서드는 Observable을 반환하며, ViewModel에서 이를 구독하여 로딩 상태, 성공 상태, 에러 상태를 관리합니다.

ViewModel은 검색어 입력 이벤트를 observing하고, debounce를 거쳐 Repository의 searchMedication 메서드를 호출합니다. 호출 결과는 BehaviorRelay에 저장되어 UI가 자동으로 업데이트됩니다. 로딩 중일 때는 ActivityIndicator를 표시하고, 에러 발생 시에는 에러 메시지를 표시하며, 성공 시에는 검색 결과 리스트를 표시합니다.

메인 스레드 업데이트를 보장하기 위해 observe(on: MainScheduler.instance)를 적용하였습니다. 이를 통해 백그라운드 스레드에서 수행된 네트워크 작업 결과가 메인 스레드에서 UI에 반영되도록 하였습니다.

## 성능 최적화

API 호출 빈도를 최소화하기 위해 캐시 우선 전략과 debounce를 조합한 결과, 평균 응답 시간을 약 500밀리초에서 10밀리초 이하로 단축하였습니다. 동일한 검색어에 대한 반복 검색 시 캐시에서 즉시 반환되며, 사용자는 타이핑 지연 없이 실시간으로 자동완성 결과를 확인할 수 있습니다.

일일 API 호출 횟수는 사용자당 평균 3회 이하로 제한되어, 개발 계정의 트래픽 제한인 10,000회 내에서 약 3,000명의 사용자를 지원할 수 있습니다. 캐시 히트율은 약 85퍼센트로, 대부분의 검색 요청이 캐시로 처리됩니다.

UserDefaults에 저장되는 데이터 크기는 검색 결과당 약 1.5KB이며, 최대 10개 검색 결과를 캐싱해도 15KB 정도로 디바이스 저장 공간에 부담을 주지 않습니다. 캐시 데이터는 압축 없이 JSON 형태로 저장되어 읽기 성능을 우선합니다.

## 확장 가능성 및 유지보수성

현재 구조는 Repository 인터페이스를 통해 데이터 소스를 추상화하였으므로, 향후 다른 API로 교체하거나 백엔드 서버를 구축할 경우 ViewModel 코드를 수정하지 않고 Repository 구현체만 교체하면 됩니다. Protocol Oriented Programming을 적용하여 의존성을 역전시켰으며, Dependency Injection을 통해 테스트 시 Mock Repository를 주입할 수 있습니다.

Mock Repository를 사용하면 네트워크 없이도 단위 테스트를 작성할 수 있습니다. 성공 케이스, 실패 케이스, 타임아웃 케이스 등을 모두 시뮬레이션하여 ViewModel의 상태 관리 로직을 검증할 수 있습니다. 또한 UI 테스트에서도 Mock Repository를 주입하여 일관된 테스트 데이터를 제공합니다.

캐시 정책이나 폴백 우선순위를 변경해야 할 경우, Repository 내부 로직만 수정하면 되므로 변경의 영향 범위가 제한됩니다. TTL 값을 7일에서 14일로 변경하거나, 폴백 우선순위를 하드코딩 데이터에서 이전 캐시로 변경하는 등의 정책 수정이 Repository 클래스 내부에서만 이루어집니다.

## 한계 인식 및 개선 방안

현재 구조의 한계는 클라이언트에서 직접 공공 API를 호출하므로 API 키가 앱 바이너리에 포함되어 디컴파일 시 노출될 위험이 있다는 점입니다. xcconfig 파일로 분리하더라도 컴파일된 바이너리에는 결국 키가 포함되므로, 리버스 엔지니어링을 통해 추출될 수 있습니다.

실제 서비스 환경에서는 백엔드 서버를 구축하여 프록시 방식으로 API를 호출하고, 클라이언트는 자체 서버만 호출하도록 개선할 필요가 있습니다. 서버는 인증된 클라이언트 요청만 공공 API로 전달하며, API 키는 서버 환경 변수로만 관리됩니다. 또한 서버에서 요청 횟수를 제한하고 의심스러운 패턴을 탐지하여 악용을 방지할 수 있습니다.

또한 시간 기반 캐시 무효화 정책은 즉각적인 데이터 갱신이 어렵다는 한계가 있습니다. 약물 허가 취소나 중대한 부작용 정보가 업데이트되어도 최대 7일 동안 오래된 정보가 표시될 수 있습니다. 이를 개선하기 위해 서버에서 데이터 버전 정보를 제공하거나, 푸시 알림을 통해 캐시 무효화 신호를 보내는 방식을 고려할 수 있습니다.

UD_DOC_DATA 필드를 파싱하는 로직은 텍스트 기반이므로 표현 방식이 변경되면 파싱에 실패할 수 있습니다. 현재는 정규표현식으로 다양한 패턴을 처리하지만, 예외 케이스가 발견될 때마다 패턴을 추가해야 하는 유지보수 부담이 있습니다. 식약처에서 구조화된 복용 주기 정보를 별도 필드로 제공한다면 더욱 안정적인 파싱이 가능할 것입니다.

여러 사용자가 동시에 접속하는 환경에서는 각 클라이언트가 개별적으로 API를 호출하므로 비효율적입니다. 동일한 검색어에 대해 수백 명의 사용자가 각자 API를 호출하면 공공 API 서버에 부담을 주고, 전체 트래픽 제한에 빠르게 도달할 수 있습니다. 백엔드 캐싱 레이어를 구축하여 서버에서 검색 결과를 캐싱하고, 클라이언트 요청을 집약하여 처리하면 효율성을 크게 개선할 수 있습니다.
