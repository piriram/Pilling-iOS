//
//  CoreDataPillCycleRepository.swift
//  PillingApp
//
//  Created by Ïû†ÎßåÎ≥¥ÍπÄÏ•¨Îîî on 10/12/25.
//

import CoreData
import RxSwift
import WidgetKit

// MARK: - CoreDataPillCycleRepository

final class CoreDataPillCycleRepository: PillCycleRepositoryProtocol {
    
    private let coreDataManager: CoreDataManager
    
    init(coreDataManager: CoreDataManager) {
        self.coreDataManager = coreDataManager
    }
    
    // MARK: - PillCycleRepositoryProtocol
    
    func fetchCurrentCycle() -> Observable<PillCycle?> {
        return coreDataManager
            .fetch(
                entityType: PillCycleEntity.self,
                sortDescriptors: [
                    NSSortDescriptor(key: "createdAt", ascending: false),
                    NSSortDescriptor(key: "startDate", ascending: false)
                ]
            )
            .map { entities in
                let cycles = entities.map { $0.toDomain() }
                guard !cycles.isEmpty else { return nil }
                
                let now = Date()
                let cal = Calendar.current
                
                // 1) ÏßÑÌñâ Ï§ë(Ïò§Îäò Ìè¨Ìï®) ÏÇ¨Ïù¥ÌÅ¥ Ïö∞ÏÑ†
                if let ongoing = cycles.first(where: { cycle in
                    let start = cycle.startDate
                    let totalDays: Int = {
                        if let mirrorVal = Mirror(reflecting: cycle).children.first(where: { $0.label == "totalDays" })?.value as? Int {
                            return mirrorVal
                        } else {
                            return cycle.activeDays + cycle.breakDays
                        }
                    }()
                    let end = cal.date(byAdding: .day, value: max(totalDays - 1, 0), to: start) ?? start
                    return (start ... end).contains(now)
                }) {
                    return ongoing
                }
                
                // 2) ÏóÜÏúºÎ©¥ createdAt ÏµúÏã† Î∞òÌôò
                return cycles.first
            }
    }
    
    func saveCycle(_ cycle: PillCycle) -> Observable<Void> {
        return Observable.create { [weak self] observer in
            guard let self = self else {
                observer.onError(CoreDataError.contextNotAvailable)
                return Disposables.create()
            }
            
            let context = self.coreDataManager.viewContext
            
            // Í∏∞Ï°¥ ÏÇ¨Ïù¥ÌÅ¥Ïù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
            let fetchRequest: NSFetchRequest<PillCycleEntity> = NSFetchRequest(entityName: "PillCycleEntity")
            fetchRequest.predicate = NSPredicate(format: "id == %@", cycle.id as CVarArg)
            
            do {
                let existingCycles = try context.fetch(fetchRequest)
                
                if let existingCycle = existingCycles.first {
                    // ÏóÖÎç∞Ïù¥Ìä∏
                    existingCycle.update(from: cycle)
                    
                    // Í∏∞Ï°¥ Î†àÏΩîÎìúÎì§ ÏÇ≠Ï†ú ÌõÑ ÏÉàÎ°ú Ï∂îÍ∞Ä
                    if let records = existingCycle.records {
                        existingCycle.removeFromRecords(records)
                    }
                    
                    cycle.records.forEach { record in
                        let recordEntity = PillRecordEntity.from(domain: record, context: context)
                        recordEntity.cycle = existingCycle
                    }
                } else {
                    // ÏÉàÎ°ú ÏÉùÏÑ±
                    _ = PillCycleEntity.from(domain: cycle, context: context)
                }
                
                try context.save()
                
                // ‚≠êÔ∏è ÏúÑÏ†Ø ÏóÖÎç∞Ïù¥Ìä∏
                WidgetCenter.shared.reloadAllTimelines()
                print("üíä ÏÇ¨Ïù¥ÌÅ¥ Ï†ÄÏû• ÏôÑÎ£å - ÏúÑÏ†Ø ÏóÖÎç∞Ïù¥Ìä∏")
                
                observer.onNext(())
                observer.onCompleted()
            } catch {
                observer.onError(CoreDataError.saveFailed(error))
            }
            
            return Disposables.create()
        }
    }
    
    func updateRecord(_ record: PillRecord, in cycleID: UUID) -> Observable<Void> {
        return Observable.create { [weak self] observer in
            guard let self = self else {
                observer.onError(CoreDataError.contextNotAvailable)
                return Disposables.create()
            }
            
            let context = self.coreDataManager.viewContext
            
            // ÏÇ¨Ïù¥ÌÅ¥ Ï∞æÍ∏∞
            let cycleFetchRequest: NSFetchRequest<PillCycleEntity> = NSFetchRequest(entityName: "PillCycleEntity")
            cycleFetchRequest.predicate = NSPredicate(format: "id == %@", cycleID as CVarArg)
            
            do {
                guard let cycleEntity = try context.fetch(cycleFetchRequest).first else {
                    observer.onError(CoreDataError.invalidData)
                    return Disposables.create()
                }
                
                // Î†àÏΩîÎìú Ï∞æÍ∏∞
                let recordFetchRequest: NSFetchRequest<PillRecordEntity> = NSFetchRequest(entityName: "PillRecordEntity")
                recordFetchRequest.predicate = NSPredicate(format: "id == %@", record.id as CVarArg)
                
                if let recordEntity = try context.fetch(recordFetchRequest).first {
                    // ÏóÖÎç∞Ïù¥Ìä∏
                    recordEntity.update(from: record)
                } else {
                    // ÏÉàÎ°ú ÏÉùÏÑ±
                    let newRecordEntity = PillRecordEntity.from(domain: record, context: context)
                    newRecordEntity.cycle = cycleEntity
                }
                
                try context.save()
                
                // ‚≠êÔ∏è ÏúÑÏ†Ø ÏóÖÎç∞Ïù¥Ìä∏
                WidgetCenter.shared.reloadAllTimelines()
                print("üíä Î≥µÏö© Í∏∞Î°ù ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å - ÏúÑÏ†Ø ÏóÖÎç∞Ïù¥Ìä∏")
                
                observer.onNext(())
                observer.onCompleted()
            } catch {
                observer.onError(CoreDataError.saveFailed(error))
            }
            
            return Disposables.create()
        }
    }
    
    // MARK: - Additional Methods
    
    func deleteAllCycles() -> Observable<Void> {
        return coreDataManager.deleteAll(entityType: PillCycleEntity.self)
            .do(onNext: {
                // ‚≠êÔ∏è ÏúÑÏ†Ø ÏóÖÎç∞Ïù¥Ìä∏
                WidgetCenter.shared.reloadAllTimelines()
                print("üóëÔ∏è Î™®Îì† ÏÇ¨Ïù¥ÌÅ¥ ÏÇ≠Ï†ú ÏôÑÎ£å - ÏúÑÏ†Ø ÏóÖÎç∞Ïù¥Ìä∏")
            })
    }
    
    func fetchAllCycles() -> Observable<[PillCycle]> {
        return coreDataManager
            .fetch(
                entityType: PillCycleEntity.self,
                sortDescriptors: [
                    NSSortDescriptor(key: "createdAt", ascending: false),
                    NSSortDescriptor(key: "startDate", ascending: false)
                ]
            )
            .map { entities in
                return entities.map { $0.toDomain() }
            }
    }
}
